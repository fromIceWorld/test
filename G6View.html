<div class="menu">
    <div class="collapse">
        <div class="collapse-header">></div>
        <span style="position: absolute; top: 3px; right: 7px">input</span>
        <div class="collapse-body">
            <div draggable="true" type="node">
                <img src="../menu/input.svg" width="160px" id="input" />
            </div>
            <div draggable="true" type="node">
                <img src="../menu/radio.svg" width="120px" id="radio" />
            </div>
            <div draggable="true" id="text" type="node">
                <span id="text">文本T</span>
            </div>
            <div draggable="true" id="form" type="combo">
                <span id="text" type="combo">form</span>
            </div>
        </div>
    </div>
</div>
<div id="container" style="width: 1920px; height: 1080px"></div>
<!-- 侧边配置栏 -->
<div class="config-menu">
    <div class="close">
        <span>o</span>
    </div>
    <div class="tabs">
        <span class="tab">config</span>
    </div>
    <div class="tab-body"></div>
</div>
<script src="./g6.min.js"></script>
<script src="./menu/input.js"></script>
<script src="./menu/radio.js"></script>
<script src="./menu/text.js"></script>
<script src="./menu/form/base-form.js"></script>
<script>
    let dragEvent,
        focusNode,
        isEdit = false,
        tabBody = document.getElementsByClassName('tab-body')[0];
    document.addEventListener('keydown', (event) => {
        // event.preventDefault();
    });
    document.addEventListener(
        'dragstart',
        function (event) {
            dragEvent = event;
            // 保存拖动元素的引用 (ref.)
            dragEvent = event.target;
            // 使其半透明
            event.target.style.opacity = 0.5;
        },
        false
    );
    document.addEventListener(
        'dragend',
        function (event) {
            // 重置透明度
            event.target.style.opacity = '';
        },
        false
    );
    document.addEventListener(
        'drop',
        function (event) {
            if (event.target.tagName === 'CANVAS') {
                let { offsetX, offsetY } = event,
                    targetX = offsetX,
                    targetY = offsetY,
                    targetType = dragEvent.getAttribute('type');
                // 阻止默认动作（如打开一些元素的链接）
                event.preventDefault();
                // 将拖动的元素到所选择的放置目标节点中
                if (targetType === 'combo') {
                    graph.createCombo(
                        {
                            x: targetX,
                            y: targetY,
                            type: 'form',
                            id: String(Math.random()),
                            padding: [5, 5, 5, 5],
                            size: [260, 50],
                            label: 'form',
                            labelCfg: {
                                refX: -1,
                                refY: -11,
                            },
                            style: {},
                        },
                        []
                    );
                } else if (targetType === 'node') {
                    graph.addItem('node', {
                        x: targetX,
                        y: targetY,
                        type: dragEvent.id,
                        config: window[
                            dragEvent.id.toLocaleUpperCase() + '_CONFIG'
                        ],
                        id: String(Math.random()),
                    });
                }
            }
        },
        false
    );
    const data = {
        nodes: [
            {
                id: 'input',
                description: '单纯的输入框,只携带 placeholder',
                x: 250,
                type: 'input',
                config: INPUT_CONFIG,
                y: 150,
            },
            {
                id: 'text',
                description: '文字',
                x: 170,
                type: 'text',
                config: TEXT_CONFIG,
                y: 200,
            },
        ],
    };
    const width = document.getElementById('container').scrollWidth;
    const height = document.getElementById('container').scrollHeight || 500;
    G6.registerCombo(
        'cRect',
        {
            drawShape: function drawShape(cfg, group) {
                const self = this;
                // 获取配置中的 Combo 内边距
                cfg.padding = cfg.padding || [50, 20, 20, 20];
                // 获取样式配置，style.width 与 style.height 对应 rect Combo 位置说明图中的 width 与 height
                // const style = self.getShapeStyle(cfg);
                const style = { width: 1200, height: 1200 };
                // 绘制一个矩形作为 keyShape，与 'rect' Combo 的 keyShape 一致
                const rect = (comboShape = group.addShape('rect', {
                    attrs: {
                        ...style,
                        x:
                            -style.width / 2 -
                            (cfg.padding[3] - cfg.padding[1]) / 2,
                        y:
                            -style.height / 2 -
                            (cfg.padding[0] - cfg.padding[2]) / 2,
                        width: style.width,
                        height: style.height,
                    },
                    draggable: true,
                    name: 'combo-keyShape',
                }));
                // 增加右侧圆
                group.addShape('circle', {
                    attrs: {
                        ...style,
                        fill: '#fff',
                        opacity: 1,
                        // cfg.style.width 与 cfg.style.heigth 对应 rect Combo 位置说明图中的 innerWdth 与 innerHeight
                        x: cfg.style.width / 2 + cfg.padding[1],
                        y: (cfg.padding[2] - cfg.padding[0]) / 2,
                        r: 5,
                    },
                    draggable: true,
                    name: 'combo-circle-shape',
                });
                return rect;
            },
            afterDraw() {},
            // 定义新增的右侧圆的位置更新逻辑
            afterUpdate: function afterUpdate(cfg, combo) {
                console.log('自定义combo');
            },
        },
        'rect'
    );
    const graph = new G6.Graph({
        container: 'container',
        width,
        height,
        // translate the graph to align the canvas's center, support by v3.5.1
        defaultNode: {
            type: 'modelRect',
        },
        modes: {
            default: ['drag-node', 'drag-combo'],
        },
        nodeStateStyles: {
            hover: {
                lineWidth: 2,
                stroke: '#1890ff',
                fill: '#e6f7ff',
            },
        },
        defaultCombo: {
            type: 'rect', // Combo 类型
            // ... 其他配置
        },
    });

    graph.data(data);
    graph.render();
    graph.createCombo(
        {
            type: 'form',
            id: 'combo1',
            padding: [5, 5, 5, 5],
            size: [260, 50],
            label: 'form',
            labelCfg: {
                refX: -1,
                refY: -11,
            },
            style: {},
        },
        ['input', 'text']
    );

    graph.on('click', (evt) => {
        const { item } = evt;
        if (item !== focusNode && focusNode) {
            tabBody.replaceChildren();
            unFocus(focusNode);
            focusNode = null;
        }
    });

    graph.on('node:click', (evt) => {
        const { item, shape } = evt,
            model = item._cfg.model,
            config = item._cfg.model.config;
        focus(item); //focus当前节点
        focusNode = item;
        tabBody.replaceChildren();
        for (let [key, value] of Object.entries(config)) {
            let row = document.createElement('div'),
                keyNative = document.createElement('div'),
                colon = document.createElement('span'),
                valueNative = document.createElement('div');
            row.setAttribute('class', 'config-row');
            colon.setAttribute('class', 'config-colon');
            colon.appendChild(new Text(' :  '));
            keyNative.setAttribute('class', 'style-key');
            valueNative.setAttribute('class', 'style-value');
            valueNative.setAttribute('contenteditable', 'true');
            valueNative.addEventListener('focus', (e) => {
                isEdit = true;
            });
            valueNative.addEventListener('blur', (e) => {
                isEdit = false;
                config[key] = valueNative.childNodes[0].nodeValue;
                // graph.removeItem(focusNode);
                // focusNode = graph.addItem('node', {
                //     ...model,
                // });
                // focus(
                //     graph.updateItem(focusNode, {
                //         ...model,
                //         x: 500,
                //     })
                // );
            });
            keyNative.appendChild(new Text(key));
            valueNative.appendChild(new Text(value));
            row.append(keyNative, colon, valueNative);
            tabBody.appendChild(row);
        }
    });
    graph.on('combo:click', (evt) => {
        console.log(evt);
    });
    graph.on('node:mouseenter', (evt) => {
        const { item } = evt;
        focus(item);
    });

    graph.on('node:mouseleave', (evt) => {
        const { item } = evt;
        if (focusNode !== item) {
            unFocus(item);
        }
    });
    graph.on('keydown', (evt) => {
        if (isEdit) {
            return;
        }
        const { item } = evt;
        if (evt.keyCode === 46) {
            //delete
            graph.removeItem(focusNode);
            focusNode = null;
        } else if (evt.keyCode >= 37 && evt.keyCode <= 40) {
            // 左上右下
            if (focusNode) {
                let { x, y } = focusNode._cfg.model;
                switch (evt.keyCode) {
                    case 37:
                        x -= 10;
                        break;
                    case 38:
                        y -= 10;
                        break;
                    case 39:
                        x += 10;
                        break;
                    case 40:
                        y += 10;
                        break;
                }
                let model = focusNode._cfg.model;
                focusNode.updatePosition({
                    x,
                    y,
                });
                evt.preventDefault();
                evt.stopPropagation();
            }
        }
    });
    function focus(item) {
        graph.updateItem(item, {
            style: {
                ...item.style,
                lineWidth: 1,
                stroke: '#1890ff',
                fill: '#00000000',
                radius: 2,
            },
        });
    }
    function unFocus(item) {
        graph.updateItem(item, {
            style: {
                ...item.style,
                lineWidth: 0,
                fill: '#00000000',
            },
        });
    }
</script>
<script>
    let collHeader = document.querySelector('.collapse-header'),
        collBody = document.querySelector('.collapse-body');
    collHeader.addEventListener('click', () => {
        if (collBody.style.display !== 'none') {
            collBody.style.display = 'none';
        } else {
            collBody.style.display = 'block';
        }
    });
</script>
<style>
    .collapse-body > div {
        margin: 6px 0;
    }
    /* 整个滚动条 */
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
        background-color: #ffffff;
        /* display: none; */
    }

    /* 鼠标指针浮动显示 */
    :hover::-webkit-scrollbar {
        display: block;
    }

    /* 滚动条轨道 */
    ::-webkit-scrollbar-track {
        /* 阴影 */
        -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
        background-color: #ffffff;
    }

    /* 滚定条滑块 */
    ::-webkit-scrollbar-thumb {
        border-radius: 30px;
        background-color: #615b5b49;
    }
    foreignObject {
        width: 100%;
        overflow: inherit;
    }
    body {
        margin: 0;
    }
    .collapse-header {
        cursor: pointer;
        background-color: #fafafa;
        padding: 5px;
    }
    .menu {
        width: 194px;
        position: absolute;
        border: 1px solid #615b5b49;
        border-bottom: none;
        border-right: none;
        padding: 2px;
    }
    #container {
        border: 1px solid #615b5b49;
        margin-left: 200px;
    }
    .config-menu {
        position: absolute;
        top: 0;
        right: 0;
        background-color: #7e7ef214;
        width: 200px;
        height: 100%;
    }
    .close {
        position: absolute;
        top: 50%;
        left: -12px;
        cursor: pointer;
    }
    .tabs {
        padding-top: 6px;
        margin-bottom: 14px;
    }
    .tab-body {
        font-size: 14px;
        padding: 0 4px;
    }
    .tab {
        border-bottom: 2px solid blue;
        padding: 5px;
        cursor: pointer;
    }
    .tab:hover {
        background-color: #d4d4de;
    }
    .config-menu {
        position: fixed;
        top: 0;
        right: 0;
        background-color: #7e7ef214;
        width: 200px;
        height: 100%;
    }
    .config-row {
        display: flex;
    }
    .config-colon {
        margin: 0 4px 0 2px;
        font-weight: 600;
    }
</style>
